<!DOCTYPE html>
<html lang="en" dir="ltr" class="client-nojs">
<head>
<title>Function template - cppreference.com</title>
<meta charset="UTF-8" />
<meta name="generator" content="MediaWiki 1.21.2" />
<link rel="alternate" type="application/x-wiki" title="Edit" href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;action=edit" />
<link rel="edit" title="Edit" href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;action=edit" />
<link rel="shortcut icon" href="../../../favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="../../../mwiki/opensearch_desc.php" title="cppreference.com (en)" />
<link rel="EditURI" type="application/rsd+xml" href="https://en.cppreference.com/mwiki/api.php?action=rsd" />
<link rel="alternate" type="application/atom+xml" title="cppreference.com Atom feed" href="https://en.cppreference.com/mwiki/index.php?title=Special:RecentChanges&amp;feed=atom" />
<link rel="stylesheet" href="../../../mwiki/load.php%3Fdebug=false&amp;lang=en&amp;modules=ext.gadget.ColiruCompiler,MathJax|ext.rtlcite|mediawiki.legacy.commonPrint,shared|skins.cppreference2&amp;only=styles&amp;skin=cppreference2&amp;*.css" />
<meta name="ResourceLoaderDynamicStyles" content="" />
<link rel="stylesheet" href="../../../mwiki/load.php%3Fdebug=false&amp;lang=en&amp;modules=site&amp;only=styles&amp;skin=cppreference2&amp;*.css" />
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>

<script src="../../../mwiki/load.php%3Fdebug=false&amp;lang=en&amp;modules=startup&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"cpp/language/function_template","wgTitle":"cpp/language/function template","wgCurRevisionId":110677,"wgArticleId":5067,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Todo with reason","Pages with unreviewed CWG DR marker"],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"cpp/language/function_template","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"gadget-ColiruCompiler":1,"gadget-MathJax":1});;},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});;},{},{});
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-js:7:9f05c6caceb9bb1a482b6cebd4c5a330 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_function_template skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        <div id="mw-head" class="noprint">
            <div id="cpp-head-first-base">
                <div id="cpp-head-first">
                    <h5><a href="../../../index.html">
                        cppreference.com                        </a></h5>
                    <div id="cpp-head-search">
                        
<!-- 0 -->
<div id="p-search">
	<h5><label for="searchInput">Search</label></h5>
	<form action="https://en.cppreference.com/mwiki/index.php" id="searchform">
		<input type='hidden' name="title" value="Special:Search"/>
				<div id="simpleSearch">
						<input name="search" title="Search cppreference.com [f]" accesskey="f" id="searchInput" />						<button type="submit" name="button" title="Search the pages for this text" id="searchButton"><img src="../../../mwiki/skins/cppreference2/images/search-ltr.png%3F303" alt="Search" /></button>					</div>
			</form>
</div>

<!-- /0 -->
                    </div>
                    <div id="cpp-head-personal">
                        
<!-- 0 -->
<div id="p-personal" class="">
<span id="pt-createaccount"><a href="https://en.cppreference.com/mwiki/index.php?title=Special:UserLogin&amp;returnto=cpp%2Flanguage%2Ffunction+template&amp;type=signup">Create account</a></span>	<div class="menu">
        <ul>
<li id="pt-login"><a href="https://en.cppreference.com/mwiki/index.php?title=Special:UserLogin&amp;returnto=cpp%2Flanguage%2Ffunction+template" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>        </ul>
    </div>
</div>

<!-- /0 -->
                    </div>

                </div>
            </div>
            <div id="cpp-head-second-base">
                <div id="cpp-head-second">
                    <div id="cpp-head-tools-left">
                        
<!-- 0 -->
<div id="p-namespaces" class="vectorTabs">
	<h5>Namespaces</h5>
	<ul>
					<li  id="ca-nstab-main" class="selected"><span><a href="function_template.html"  title="View the content page [c]" accesskey="c">Page</a></span></li>
					<li  id="ca-talk"><span><a href="https://en.cppreference.com/w/Talk:cpp/language/function_template"  title="Discussion about the content page [t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-variants" class="vectorMenu emptyPortlet">
		<h5><span>Variants</span><a href="function_template.html#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
                    </div>
                    <div id="cpp-head-tools-right">
                        
<!-- 0 -->
<div id="p-views" class="vectorTabs">
	<h5>Views</h5>
	<ul>
					<li id="ca-view" class="selected"><span><a href="function_template.html" >View</a></span></li>
					<li id="ca-edit"><span><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;action=edit"  title="You can edit this page. Please use the preview button before saving [e]" accesskey="e">Edit</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;action=history"  title="Past revisions of this page [h]" accesskey="h">History</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-cactions" class="vectorMenu emptyPortlet">
	<h5><span>Actions</span><a href="function_template.html#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
                    </div>
                </div>
            </div>
        </div>
        <!-- /header -->
        <!-- content -->
<style type="text/css">
#carbonads {
  display: block;
  overflow: hidden;
  position: absolute;
  text-align: center;
  left: -170px;
  max-width: 150px;
  border-radius: 4px;
  border: solid 1px hsla(0, 0%, 0%, .1);
  background-color: hsl(0, 0%, 98%);
  font-size: 12px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.5;
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

.carbon-img {
  display: block;
  margin-bottom: 8px;
  max-width: 150px;
  line-height: 1;
}

.carbon-img img {
  display: block;
  margin: 0 auto;
  max-width: 150px !important;
  width: 150px;
  height: auto;
}

.carbon-text {
  display: block;
  padding: 0 1em 8px;
}

.carbon-poweredby {
  display: block;
  padding: 8px 12px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
</style>
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<script async type="text/javascript" src="https://cdn.carbonads.com/carbon.js?serve=CKYITK7M&amp;placement=cppreferencecom" id="_carbonads_js"></script>
                <h1 id="firstHeading" class="firstHeading">Function template</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">From cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a>&lrm; | <a href="../language.html" title="cpp/language">language</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="t-navbar" style=""><div class="t-navbar-sep">&#160;</div><div class="t-navbar-head"><a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div><div><table class="t-nv-begin" cellpadding="0" style="line-height:1.1em;">
<tr class="t-nv"><td colspan="5"> <a href="../language.html" title="cpp/language"> Language</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../header.html" title="cpp/header"> Standard Library Headers</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../freestanding.html" title="cpp/freestanding"> Freestanding and hosted implementations</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../named_req.html" title="cpp/named req"> Named requirements </a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html#Language_support" title="cpp/utility"> Language support library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../concepts.html" title="cpp/concepts"> Concepts library</a> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../error.html" title="cpp/error"> Diagnostics library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html" title="cpp/utility"> Utilities library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../string.html" title="cpp/string"> Strings library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../container.html" title="cpp/container"> Containers library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../iterator.html" title="cpp/iterator"> Iterators library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../ranges.html" title="cpp/ranges"> Ranges library</a> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../algorithm.html" title="cpp/algorithm"> Algorithms library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../numeric.html" title="cpp/numeric"> Numerics library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../io.html" title="cpp/io"> Input/output library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../locale.html" title="cpp/locale"> Localizations library</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../regex.html" title="cpp/regex"> Regular expressions library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../atomic.html" title="cpp/atomic"> Atomic operations library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../thread.html" title="cpp/thread"> Thread support library</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../filesystem.html" title="cpp/filesystem"> Filesystem library</a> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../experimental.html" title="cpp/experimental"> Technical Specifications</a> </td></tr>
</table></div><div><span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/navbar_content&amp;action=edit">&#91;edit&#93;</a></span></div></div></div></div><div class="t-navbar-sep">&#160;</div><div class="t-navbar-head"><a href="../language.html" title="cpp/language"> C++ language</a></div><div class="t-navbar-sep">&#160;</div><div class="t-navbar-head"><a href="templates.html" title="cpp/language/templates"> Templates</a><div class="t-navbar-menu"><div><div style="display:inline-block">
<div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="template_parameters.html" title="cpp/language/template parameters"> parameters and arguments</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="class_template.html" title="cpp/language/class template"> class templates</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <strong class="selflink"> function templates</strong> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="member_template.html" title="cpp/language/member template"> class member templates</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="variable_template.html" title="cpp/language/variable template"> variable templates</a><span class="t-mark-rev t-since-cxx14">(C++14)</span></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="template_argument_deduction.html" title="cpp/language/template argument deduction"> template argument deduction</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="deduction_guide.html" title="cpp/language/class template argument deduction"> class template argument deduction</a><span class="t-mark-rev t-since-cxx17">(C++17)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="template_specialization.html" title="cpp/language/template specialization"> explicit (full) specialization</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="partial_specialization.html" title="cpp/language/partial specialization"> partial specialization</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="dependent_name.html" title="cpp/language/dependent name"> dependent names</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="parameter_pack.html" title="cpp/language/parameter pack"> parameter packs</a><span class="t-mark-rev t-since-cxx11">(C++11)</span></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="sizeof....html" title="cpp/language/sizeof..."><span class="t-lines"><span>sizeof...</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="fold.html" title="cpp/language/fold"> fold-expressions</a><span class="t-mark-rev t-since-cxx17">(C++17)</span></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="sfinae.html" title="cpp/language/sfinae"> SFINAE</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="constraints.html" title="cpp/language/constraints"> Constraints and concepts</a><span class="t-mark-rev t-since-cxx20">(C++20)</span> </td></tr>
</table></div>
</div><div><span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/templates/navbar_content&amp;action=edit">&#91;edit&#93;</a></span></div></div></div></div><div class="t-navbar-sep">&#160;</div></div>
<p>A function template defines a family of functions.
</p>
<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="function_template.html#Syntax"><span class="tocnumber">1</span> <span class="toctext">Syntax</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="function_template.html#Explanation"><span class="tocnumber">2</span> <span class="toctext">Explanation</span></a></li>
<li class="toclevel-1"><a href="function_template.html#Abbreviated_function_template"><span class="tocnumber">3</span> <span class="toctext">Abbreviated function template</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="function_template.html#Function_template_instantiation"><span class="tocnumber">4</span> <span class="toctext">Function template instantiation</span></a>
<ul>
<li class="toclevel-2 tocsection-5"><a href="function_template.html#Explicit_instantiation"><span class="tocnumber">4.1</span> <span class="toctext">Explicit instantiation</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="function_template.html#Implicit_instantiation"><span class="tocnumber">4.2</span> <span class="toctext">Implicit instantiation</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="function_template.html#Template_argument_deduction"><span class="tocnumber">5</span> <span class="toctext">Template argument deduction</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="function_template.html#Explicit_template_arguments"><span class="tocnumber">6</span> <span class="toctext">Explicit template arguments</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="function_template.html#Template_argument_substitution"><span class="tocnumber">7</span> <span class="toctext">Template argument substitution</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="function_template.html#Function_template_overloading"><span class="tocnumber">8</span> <span class="toctext">Function template overloading</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="function_template.html#Function_overloads_vs_function_specializations"><span class="tocnumber">9</span> <span class="toctext">Function overloads vs function specializations</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="function_template.html#Function_template_specialization"><span class="tocnumber">10</span> <span class="toctext">Function template specialization</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="function_template.html#Defect_reports"><span class="tocnumber">11</span> <span class="toctext">Defect reports</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="function_template.html#See_Also"><span class="tocnumber">12</span> <span class="toctext">See Also</span></a></li>
</ul>
</td></tr></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;action=edit&amp;section=1" title="Edit section: Syntax">edit</a>]</span> <span class="mw-headline" id="Syntax">Syntax</span></h3>
<table class="t-sdsc-begin">

<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <code><b>template</b></code> <code><b>&lt;</b></code> <span class="t-spar">parameter-list</span> <code><b>&gt;</b></code> <span class="t-spar">function-declaration</span>
</td>
<td> (1)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <code><b>template</b></code> <code><b>&lt;</b></code> <span class="t-spar">parameter-list</span> <code><b>&gt;</b></code> <code><b>requires</b></code> <span class="t-spar">constraint</span> <span class="t-spar">function-declaration</span>
</td>
<td> (2)
</td>
<td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span>
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">function-declaration-with-placeholders</span>
</td>
<td> (3)
</td>
<td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span>
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <code><b>export</b></code> <code><b>template</b></code> <code><b>&lt;</b></code> <span class="t-spar">parameter-list</span> <code><b>&gt;</b></code> <span class="t-spar">function-declaration</span>
</td>
<td> (4)
</td>
<td> <span class="t-mark-rev t-until-cxx11">(until C++11)</span>
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;action=edit&amp;section=2" title="Edit section: Explanation">edit</a>]</span> <span class="mw-headline" id="Explanation">Explanation</span></h3>
<table class="t-par-begin">


<tr class="t-par">
<td>  <span class="t-spar">parameter-list</span>
</td>
<td> -
</td>
<td>  a non-empty comma-separated list of the <a href="template_parameters.html" title="cpp/language/template parameters">template parameters</a>, each of which is either <a href="template_parameters.html#Non-type_template_parameter" title="cpp/language/template parameters">non-type parameter</a>, a <a href="template_parameters.html#Type_template_parameter" title="cpp/language/template parameters">type parameter</a>, a <a href="template_parameters.html#Template_template_parameter" title="cpp/language/template parameters">template parameter</a>, or a <a href="parameter_pack.html" title="cpp/language/parameter pack">parameter pack</a> of any of those. <span class="t-rev-inl t-since-cxx20"><span>As with any template, parameters may be <a href="template_parameters.html#Constrained_template_parameter" title="cpp/language/template parameters">constrained</a></span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>
</td></tr>
<tr class="t-par">
<td>  <span class="t-spar">function-declaration</span>
</td>
<td> -
</td>
<td>  a <a href="function.html" title="cpp/language/function">function declaration</a>. The function name declared becomes a template name.
</td></tr>
<tr class="t-par">
<td>  <span class="t-spar">constraint</span><span class="t-mark-rev t-since-cxx20">(C++20)</span>
</td>
<td> -
</td>
<td>  a <a href="constraints.html" title="cpp/language/constraints">constraint expression</a> which restricts the template parameters accepted by this function template
</td></tr>
<tr class="t-par">
<td>  <span class="t-spar">function-declaration-with-placeholders</span><span class="t-mark-rev t-since-cxx20">(since C++20)</span>
</td>
<td> -
</td>
<td>  a <a href="function.html" title="cpp/language/function">function declaration</a> where the type of at least one parameter uses the placeholder <a href="auto.html" title="cpp/language/auto">auto</a> or <span class="t-c"><span class="mw-geshi cpp source-cpp">Concept <span class="kw4">auto</span></span></span>: the template parameter list will have one invented parameter for each placeholder (see Abbreviated function templates below
</td></tr></table>
 <table class="t-rev-begin">
<tr class="t-rev t-until-cxx11"><td>
<p><code>export</code> was an optional modifier which declared the template as <i>exported</i> (when used with a class template, it declared all of its members exported as well). Files that instantiated exported templates did not need to include their definitions: the declaration was sufficient. Implementations of <code>export</code> were rare and disagreed with each other on details.
</p>
</td>
<td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td></tr>
</table>
 <table class="t-rev-begin">
<tr class="t-rev t-since-cxx20"><td>
<h3> <span class="mw-headline" id="Abbreviated_function_template">Abbreviated function template</span></h3>
<p>When placeholder types (either <code>auto</code> or <a href="../concepts.html" title="cpp/concepts">Concept auto</a>) appear in the parameter list of a function declaration or of a function template declaration, the declaration declares a function template, and one invented template parameter for each placeholder is appended to the template parameter list
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> f1<span class="br0">&#40;</span><span class="kw4">auto</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// same as template&lt;class T&gt; void f(T)</span>
<span class="kw4">void</span> f2<span class="br0">&#40;</span>C1 <span class="kw4">auto</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// same as template&lt;C1 T&gt; void f2(T), if C1 is a concept</span>
<span class="kw4">void</span> f3<span class="br0">&#40;</span>C2 <span class="kw4">auto</span>...<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// same as template&lt;C2... Ts&gt; void f3(Ts...), if C2 is a concept</span>
<span class="kw4">void</span> f4<span class="br0">&#40;</span><span class="kw4">const</span> C3 <span class="kw4">auto</span><span class="sy2">*</span>, C4 <span class="kw4">auto</span><span class="sy3">&amp;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// same as template&lt;C3 T, C4 U&gt; void f4(const T*, U&amp;);</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T, C U<span class="sy1">&gt;</span>
<span class="kw4">void</span> g<span class="br0">&#40;</span>T x, U y, C <span class="kw4">auto</span> z<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// same as template&lt;class T, C U, C W&gt; void g(T x, U y, W z);</span></pre></div></div>
<p>Abbreviated function templates can be specialized like all function templates.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;&gt;</span>
<span class="kw4">void</span> f4<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">&#40;</span><span class="kw4">const</span> <span class="kw4">int</span><span class="sy2">*</span>, <span class="kw4">const</span> <span class="kw4">double</span><span class="sy3">&amp;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// specialization of f4&lt;int, const double&gt;</span></pre></div></div>
<p><br />
</p>
</td>
<td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td></tr>
</table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;action=edit&amp;section=4" title="Edit section: Function template instantiation">edit</a>]</span> <span class="mw-headline" id="Function_template_instantiation">Function template instantiation</span></h3>
<p>A function template by itself is not a type, or a function, or any other entity. No code is generated from a source file that contains only template definitions. In order for any code to appear, a template must be instantiated: the template arguments must be determined so that the compiler can generate an actual function (or class, from a class template).
</p>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;action=edit&amp;section=5" title="Edit section: Explicit instantiation">edit</a>]</span> <span class="mw-headline" id="Explicit_instantiation">Explicit instantiation</span></h4>
<table class="t-sdsc-begin">

<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <code><b>template</b></code> <span class="t-spar">return-type</span> <span class="t-spar">name</span> <code><b>&lt;</b></code>  <span class="t-spar">argument-list</span> <code><b>&gt;</b></code> <code><b>(</b></code> <span class="t-spar">parameter-list</span> <code><b>)</b></code> <code><b>;</b></code>
</td>
<td> (1)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <code><b>template</b></code> <span class="t-spar">return-type</span> <span class="t-spar">name</span> <code><b>(</b></code> <span class="t-spar">parameter-list</span> <code><b>)</b></code> <code><b>;</b></code>
</td>
<td> (2)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <code><b>extern</b></code> <code><b>template</b></code> <span class="t-spar">return-type</span> <span class="t-spar">name</span> <code><b>&lt;</b></code> <span class="t-spar">argument-list</span> <code><b>&gt;</b></code> <code><b>(</b></code> <span class="t-spar">parameter-list</span> <code><b>)</b></code> <code><b>;</b></code>
</td>
<td> (3)
</td>
<td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <code><b>extern</b></code> <code><b>template</b></code> <span class="t-spar">return-type</span> <span class="t-spar">name</span> <code><b>(</b></code> <span class="t-spar">parameter-list</span> <code><b>)</b></code> <code><b>;</b></code>
</td>
<td> (4)
</td>
<td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></table>
<div class="t-li1"><span class="t-li">1)</span> Explicit instantiation definition (without <a href="template_argument_deduction.html" title="cpp/language/template argument deduction">template argument deduction</a> if every non-default template parameter is explicitly specified)</div>
<div class="t-li1"><span class="t-li">2)</span> Explicit instantiation definition with template argument deduction for all parameters</div>
<div class="t-li1"><span class="t-li">3)</span> Explicit instantiation declaration (without template argument deduction if every non-default template parameter is explicitly specified)</div>
<div class="t-li1"><span class="t-li">4)</span> Explicit instantiation declaration with template argument deduction for all parameters</div>
<p>An explicit instantiation definition forces instantiation of the function or member function they refer to. It may appear in the program anywhere after the template definition, and for a given argument-list, is only allowed to appear once in the program.
</p>
 <table class="t-rev-begin">
<tr class="t-rev t-since-cxx11"><td>
<p>An explicit instantiation declaration (an extern template) prevents implicit instantiations: the code that would otherwise cause an implicit instantiation has to use the explicit instantiation definition provided somewhere else in the program.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td></tr>
</table>
<p>A trailing template-argument can be left unspecified in an explicit instantiation of a function template specialization or of a member function template specialization if it can be <a href="template_argument_deduction.html" title="cpp/language/template argument deduction">deduced</a> from the function parameter
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> f<span class="br0">&#40;</span>T s<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> s <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&#160;
<span class="kw1">template</span> <span class="kw4">void</span> f<span class="sy1">&lt;</span><span class="kw4">double</span><span class="sy1">&gt;</span><span class="br0">&#40;</span><span class="kw4">double</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// instantiates f&lt;double&gt;(double)</span>
<span class="kw1">template</span> <span class="kw4">void</span> f<span class="sy1">&lt;&gt;</span><span class="br0">&#40;</span><span class="kw4">char</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// instantiates f&lt;char&gt;(char), template argument deduced</span>
<span class="kw1">template</span> <span class="kw4">void</span> f<span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// instantiates f&lt;int&gt;(int), template argument deduced</span></pre></div></div>
<p>Explicit instantiation of a function template or of a member function of a class template cannot use <code>inline</code> or <code>constexpr</code>. If the declaration of the explicit instantiation names an implicitly-declared special member function, the program is ill-formed.
</p><p>Explicit instantiation declarations do not suppress the implicit instantiation of <a href="inline.html" title="cpp/language/inline">inline</a> functions, <a href="auto.html" title="cpp/language/auto">auto</a>-declarations, references, and class template specializations. (thus, when the inline function that is a subject of explicit instantiation declaration is ODR-used, it is implicitly instantiated for inlining, but its out-of-line copy is not generated in this TU)
</p><p>Explicit instantiation definition of a function template with <a href="default_arguments.html" title="cpp/language/default arguments">default arguments</a> is not a use of the arguments, and does not attempt to initialize them:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">char</span><span class="sy2">*</span> p <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> T g<span class="br0">&#40;</span>T x <span class="sy1">=</span> <span class="sy3">&amp;</span>p<span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="kw1">return</span> x<span class="sy4">;</span> <span class="br0">&#125;</span>
<span class="kw1">template</span> <span class="kw4">int</span> g<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="sy4">;</span>   <span class="co1">// OK even though &amp;p isn’t an int.</span></pre></div></div>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;action=edit&amp;section=6" title="Edit section: Implicit instantiation">edit</a>]</span> <span class="mw-headline" id="Implicit_instantiation">Implicit instantiation</span></h4>
<p>When code refers to a function in context that requires the function definition to exist, and this particular function has not been explicitly instantiated, implicit instantiation occurs. The list of template arguments does not have to be supplied if it can be <a href="template_argument_deduction.html" title="cpp/language/template argument deduction">deduced</a> from context
</p>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
&#160;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> f<span class="br0">&#40;</span>T s<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> s <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    f<span class="sy1">&lt;</span><span class="kw4">double</span><span class="sy1">&gt;</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// instantiates and calls f&lt;double&gt;(double)</span>
    f<span class="sy1">&lt;&gt;</span><span class="br0">&#40;</span><span class="st0">'a'</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// instantiates and calls f&lt;char&gt;(char)</span>
    f<span class="br0">&#40;</span><span class="nu0">7</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// instantiates and calls f&lt;int&gt;(int)</span>
    <span class="kw4">void</span> <span class="br0">&#40;</span><span class="sy2">*</span>ptr<span class="br0">&#41;</span><span class="br0">&#40;</span><a href="../string/basic_string.html"><span class="kw1227">std::<span class="me2">string</span></span></a><span class="br0">&#41;</span> <span class="sy1">=</span> f<span class="sy4">;</span> <span class="co1">// instantiates f&lt;string&gt;(string)</span>
<span class="br0">&#125;</span></pre></div></div>
<p><br /> 
</p>
</div>
<p>Note: omitting <code>&lt;&gt;</code> entirely allows <a href="overload_resolution.html" title="cpp/language/overload resolution">overload resolution</a> to examine both template and non-template overloads.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;action=edit&amp;section=7" title="Edit section: Template argument deduction">edit</a>]</span> <span class="mw-headline" id="Template_argument_deduction">Template argument deduction</span></h3>
<p>In order to instantiate a <strong class="selflink">function template</strong>, every template argument must be known, but not every template argument has to be specified. When possible, the compiler will deduce the missing template arguments from the function arguments. This occurs when a function call is attempted and when an address of a function template is taken.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> To, <span class="kw1">typename</span> From<span class="sy1">&gt;</span> To convert<span class="br0">&#40;</span>From f<span class="br0">&#41;</span><span class="sy4">;</span>
&#160;
<span class="kw4">void</span> g<span class="br0">&#40;</span><span class="kw4">double</span> d<span class="br0">&#41;</span> 
<span class="br0">&#123;</span>
    <span class="kw4">int</span> i <span class="sy1">=</span> convert<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">&#40;</span>d<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// calls convert&lt;int,double&gt;(double)</span>
    <span class="kw4">char</span> c <span class="sy1">=</span> convert<span class="sy1">&lt;</span><span class="kw4">char</span><span class="sy1">&gt;</span><span class="br0">&#40;</span>d<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// calls convert&lt;char,double&gt;(double)</span>
    <span class="kw4">int</span><span class="br0">&#40;</span><span class="sy2">*</span>ptr<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">float</span><span class="br0">&#41;</span> <span class="sy1">=</span> convert<span class="sy4">;</span> <span class="co1">// instantiates convert&lt;int, float&gt;(float)</span>
<span class="br0">&#125;</span></pre></div></div>
<p>This mechanism makes it possible to use template operators, since there is no syntax to specify template arguments for an operator other than by re-writing it as a function call expression.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> 
<span class="br0">&#123;</span>
    <a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;Hello, world&quot;</span> <span class="sy1">&lt;&lt;</span> <a href="../io/manip/endl.html"><span class="kw1788">std::<span class="me2">endl</span></span></a><span class="sy4">;</span>
    <span class="co1">// operator&lt;&lt; is looked up via ADL as std::operator&lt;&lt;,</span>
    <span class="co1">// then deduced to operator&lt;&lt;&lt;char, std::char_traits&lt;char&gt;&gt; both times</span>
    <span class="co1">// std::endl is deduced to &amp;std::endl&lt;char, std::char_traits&lt;char&gt;&gt;</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Template argument deduction takes place after the function template <a href="lookup.html" title="cpp/language/lookup">name lookup</a> (which may involve <a href="adl.html" title="cpp/language/adl">argument-dependent lookup</a>) and before <a href="overload_resolution.html" title="cpp/language/overload resolution">overload resolution</a>.
</p><p>See <a href="template_argument_deduction.html" title="cpp/language/template argument deduction">template argument deduction</a> for details.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;action=edit&amp;section=8" title="Edit section: Explicit template arguments">edit</a>]</span> <span class="mw-headline" id="Explicit_template_arguments">Explicit template arguments</span></h3>
<p>Template arguments of a function template may be obtained from
</p>
<ul><li> template argument deduction
</li><li> default template arguments
</li><li> specified explicitly, which can be done in the following contexts:
</li></ul>
<dl><dd><ul><li> in a function call expression
</li><li> when an address of a function is taken
</li><li> when a reference to function is initialized 
</li><li> when a pointer to member function is formed
</li><li> in an explicit specialization
</li><li> in an explicit instantiation
</li><li> in a friend declaration
</li></ul>
</dd></dl>
<p>There is no way to explicitly specify template arguments to <a href="operators.html" title="cpp/language/operators">overloaded operators</a>, <a href="cast_operator.html" title="cpp/language/cast operator">conversion functions</a>, and constructors, because they are called without the use of the function name.
</p><p>The specified template arguments must match the template parameters in kind (i.e., type for type, non-type for non-type, and template for template). There cannot be more arguments than there are parameters (unless one parameter is a parameter pack, in which case there has to be an argument for each non-pack parameter)
</p><p>The specified non-type arguments must either match the types of the corresponding non-type template parameters, or be <a href="template_parameters.html#Template_non-type_arguments" title="cpp/language/template parameters">convertible to them</a>.
</p><p>The function parameters that do not participate in template argument deduction (e.g. if the corresponding template arguments are explicitly specified) are subject to implicit conversions to the type of the corresponding function parameter (as in the usual <a href="overload_resolution.html" title="cpp/language/overload resolution">overload resolution</a>).
</p><p>A template parameter pack that is explicitly specified may be extended by template argument deduction if there are additional arguments:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ... <span class="me1">Types</span><span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>Types ... <span class="me1">values</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw4">void</span> g<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  f<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy2">*</span>, <span class="kw4">float</span><span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">&#40;</span><span class="nu0">0</span>, <span class="nu0">0</span>, <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// Types = {int*, float*, int}</span>
<span class="br0">&#125;</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;action=edit&amp;section=9" title="Edit section: Template argument substitution">edit</a>]</span> <span class="mw-headline" id="Template_argument_substitution">Template argument substitution</span></h3>
<p>When all template arguments have been specified, deduced or obtained from default template arguments, every use of a template parameter in the function parameter list is replaced with the corresponding template arguments.
</p><p>Substitution failure (that is, failure to replace template parameters with the deduced or provided template arguments) of a function template removes the function template from the <a href="overload_resolution.html" title="cpp/language/overload resolution">overload set</a>. This allows a number of ways to manipulate overload sets using template metaprogramming: see <a href="sfinae.html" title="cpp/language/sfinae">SFINAE</a> for details.
</p><p>After substitution, all function parameters of array and function type are adjusted to pointers and all top-level cv-qualifiers are dropped from function parameters (as in a regular <a href="function.html#Function_declaration" title="cpp/language/function">function declaration</a>).
</p><p>The removal of the top-level cv-qualifiers does not affect the type of the parameter as it appears within the function:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T t<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> X<span class="sy1">&gt;</span> <span class="kw4">void</span> g<span class="br0">&#40;</span><span class="kw4">const</span> X x<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> Z<span class="sy1">&gt;</span> <span class="kw4">void</span> h<span class="br0">&#40;</span>Z z, Z<span class="sy2">*</span> zp<span class="br0">&#41;</span><span class="sy4">;</span>
&#160;
<span class="co1">// two different functions with the same type, but </span>
<span class="co1">// within the function, t has different cv qualifications</span>
f<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>       <span class="co1">// function type is void(int), t is int</span>
f<span class="sy1">&lt;</span><span class="kw4">const</span> <span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// function type is void(int), t is const int</span>
&#160;
<span class="co1">// two different functions with the same type and the same x</span>
<span class="co1">// (pointers to these two functions are not equal,</span>
<span class="co1">//  and function-local statics would have different addresses)</span>
g<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>       <span class="co1">// function type is void(int), x is const int</span>
g<span class="sy1">&lt;</span><span class="kw4">const</span> <span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// function type is void(int), x is const int</span>
&#160;
<span class="co1">// only top-level cv-qualifiers are dropped:</span>
h<span class="sy1">&lt;</span><span class="kw4">const</span> <span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">&#40;</span><span class="nu0">1</span>, <a href="../types/NULL.html"><span class="kw103">NULL</span></a><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// function type is void(int, const int*) </span>
                       <span class="co1">// z is const int, zp is const int*</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;action=edit&amp;section=10" title="Edit section: Function template overloading">edit</a>]</span> <span class="mw-headline" id="Function_template_overloading">Function template overloading</span></h3>
<p>Function templates and non-template functions may be overloaded.
</p><p>A non-template function is always distinct from a template specialization with the same type. Specializations of different function templates are always distinct from each other even if they have the same type. Two function templates with the same return type and the same parameter list are distinct and can be distinguished with explicit template argument list.
</p><p>When an expression that uses type or non-type template parameters appears in the function parameter list or in the return type, that expression remains a part of the function template signature for the purpose of overloading:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw4">int</span> I, <span class="kw4">int</span> J<span class="sy1">&gt;</span> A<span class="sy1">&lt;</span>I<span class="sy2">+</span>J<span class="sy1">&gt;</span> f<span class="br0">&#40;</span>A<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span>, A<span class="sy1">&lt;</span>J<span class="sy1">&gt;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// overload #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw4">int</span> K, <span class="kw4">int</span> L<span class="sy1">&gt;</span> A<span class="sy1">&lt;</span>K<span class="sy2">+</span>L<span class="sy1">&gt;</span> f<span class="br0">&#40;</span>A<span class="sy1">&lt;</span>K<span class="sy1">&gt;</span>, A<span class="sy1">&lt;</span>L<span class="sy1">&gt;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// same as #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw4">int</span> I, <span class="kw4">int</span> J<span class="sy1">&gt;</span> A<span class="sy1">&lt;</span>I<span class="sy2">-</span>J<span class="sy1">&gt;</span> f<span class="br0">&#40;</span>A<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span>, A<span class="sy1">&lt;</span>J<span class="sy1">&gt;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// overload #2</span></pre></div></div>
<p>Two expressions involving template parameters are called <i>equivalent</i> if two function definitions that contain these expressions would be the same under <a href="definition.html#One_Definition_Rule" title="cpp/language/definition">ODR rules</a>, that is, the two expressions contain the same sequence of tokens whose names are resolved to same entities via name lookup, except template parameters may be differently named. <span class="t-rev-inl t-since-cxx20"><span>Two <a href="lambda.html" title="cpp/language/lambda">lambda expressions</a> are never equivalent.</span> <span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw4">int</span> I, <span class="kw4">int</span> J<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>A<span class="sy1">&lt;</span>I<span class="sy2">+</span>J<span class="sy1">&gt;</span><span class="br0">&#41;</span><span class="sy4">;</span>  <span class="co1">// template overload #1</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw4">int</span> K, <span class="kw4">int</span> L<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>A<span class="sy1">&lt;</span>K<span class="sy2">+</span>L<span class="sy1">&gt;</span><span class="br0">&#41;</span><span class="sy4">;</span>  <span class="co1">// equivalent to #1</span></pre></div></div>
 <table class="t-rev-begin">
<tr class="t-rev t-since-cxx14"><td>
<p>When determining if two <a href="dependent_name.html" title="cpp/language/dependent name">dependent expressions</a> are equivalent, only the dependent names involved are considered, not the results of name lookup. If multiple declarations of the same template differ in the result of name lookup, the first such declaration is used:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> decltype<span class="br0">&#40;</span>g<span class="br0">&#40;</span>T<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> h<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// decltype(g(T())) is a dependent type</span>
<span class="kw4">int</span> g<span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> decltype<span class="br0">&#40;</span>g<span class="br0">&#40;</span>T<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="br0">&#41;</span> h<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="co1">// redeclaration of h() uses earlier lookup</span>
    <span class="kw1">return</span> g<span class="br0">&#40;</span>T<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>                     <span class="co1">// ...although the lookup here does find g(int)</span>
<span class="br0">&#125;</span>
<span class="kw4">int</span> i <span class="sy1">=</span> h<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>   <span class="co1">// template argument substitution fails; g(int)</span>
                    <span class="co1">// was not in scope at the first declaration of h()</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td></tr>
</table>
<p>Two function templates are considered <i>equivalent</i> if
</p>
<ul><li> they are declared in the same scope
</li><li> they have the same name
</li><li> they have identical template parameter lists
</li><li> the expressions involving template parameters in their return types and parameter lists are <i>equivalent</i>
</li></ul>
 <table class="t-rev-begin">
<tr class="t-rev t-since-cxx20"><td>
<ul><li> the expressions in their requires-clauses that follow the template parameter lists, if present, are equivalent
</li><li> the expressions in their requires-clauses that follow the function declarators, if present, are equivalent
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td></tr>
</table>
<p>Two expressions involving template parameters are called <i>functionally equivalent</i> if they are not <i>equivalent</i>, but for any given set of template arguments, the evaluation of the two expressions results in the same value.
</p><p>Two function templates are considered <i>functionally equivalent</i> if they are <i>equivalent</i>, except that one or more expressions that involve template parameters in their return types and parameter lists are <i>functionally equivalent</i>.
</p>
 <table class="t-rev-begin">
<tr class="t-rev t-since-cxx20"><td>
<p>In addition, two function templates are <i>functionally equivalent</i> but not <i>equivalent</i> if their constraints are specified differently, but they accept and are satisfied by the same set of template argument lists.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td></tr>
</table>
<p>If a program contains declarations of function templates that are <i>functionally equivalent</i> but not <i>equivalent</i>, the program is ill-formed; no diagnostic is required.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// equivalent</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw4">int</span> I<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>A<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span>, A<span class="sy1">&lt;</span>I<span class="sy2">+</span><span class="nu0">10</span><span class="sy1">&gt;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// overload #1</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw4">int</span> I<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>A<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span>, A<span class="sy1">&lt;</span>I<span class="sy2">+</span><span class="nu0">10</span><span class="sy1">&gt;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// redeclaration of overload #1</span>
&#160;
<span class="co1">// not equivalent</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw4">int</span> I<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>A<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span>, A<span class="sy1">&lt;</span>I<span class="sy2">+</span><span class="nu0">10</span><span class="sy1">&gt;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// overload #1</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw4">int</span> I<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>A<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span>, A<span class="sy1">&lt;</span>I<span class="sy2">+</span><span class="nu0">11</span><span class="sy1">&gt;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// overload #2</span>
&#160;
<span class="co1">// functionally-equivalent but not equivalent</span>
<span class="co1">// This program is ill-formed, no diagnostic required</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw4">int</span> I<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>A<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span>, A<span class="sy1">&lt;</span>I<span class="sy2">+</span><span class="nu0">10</span><span class="sy1">&gt;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// overload #1</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw4">int</span> I<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>A<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span>, A<span class="sy1">&lt;</span>I<span class="sy2">+</span><span class="nu0">1</span><span class="sy2">+</span><span class="nu0">2</span><span class="sy2">+</span><span class="nu0">3</span><span class="sy2">+</span><span class="nu0">4</span><span class="sy1">&gt;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// functionally equivalent</span></pre></div></div>
<p>When the same function template specialization matches more than one overloaded function template (this often results from <a href="template_argument_deduction.html" title="cpp/language/template argument deduction">template argument deduction</a>), <i>partial ordering of overloaded function templates</i> is performed to select the best match. 
</p><p>Specifically, partial ordering takes place in the following situations:
</p>
<div class="t-li1"><span class="t-li">1)</span> <a href="overload_resolution.html" title="cpp/language/overload resolution">overload resolution</a> for a call to a function template specialization
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> X<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>X a<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> X<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>X<span class="sy2">*</span> a<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw4">int</span><span class="sy2">*</span> p<span class="sy4">;</span>
f<span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="sy4">;</span></pre></div></div></div>
<div class="t-li1"><span class="t-li">2)</span> when the <a href="overloaded_address.html" title="cpp/language/overloaded address">address of a function template specialization</a> is taken
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> X<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>X a<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> X<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>X<span class="sy2">*</span> a<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="kw4">void</span> <span class="br0">&#40;</span><span class="sy2">*</span>p<span class="br0">&#41;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="sy2">*</span><span class="br0">&#41;</span> <span class="sy1">=</span> <span class="sy3">&amp;</span>f<span class="sy4">;</span></pre></div></div></div>
<div class="t-li1"><span class="t-li">3)</span> when a <a href="../memory/new/operator_delete.html" title="cpp/memory/new/operator delete">placement operator delete</a> that is a function template specialization is selected to match a placement operator new
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br />Reason: mini-example </td></tr></table></div>
<div class="t-li1"><span class="t-li">4)</span> when a <a href="friend.html#Template_friends" title="cpp/language/friend">friend function declaration</a>, an <a href="function_template.html#Explicit_instantiation" title="cpp/language/function template">explicit instantiation</a>, or an <a href="template_specialization.html" title="cpp/language/template specialization">explicit specialization</a> refers to a function template specialization
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> X<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>X a<span class="br0">&#41;</span><span class="sy4">;</span>  <span class="co1">// first template f</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> X<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>X<span class="sy2">*</span> a<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// second template f</span>
<span class="kw1">template</span><span class="sy1">&lt;&gt;</span> <span class="kw4">void</span> f<span class="sy1">&lt;&gt;</span><span class="br0">&#40;</span><span class="kw4">int</span> <span class="sy2">*</span>a<span class="br0">&#41;</span> <span class="br0">&#123;</span><span class="br0">&#125;</span> <span class="co1">// explicit specialization</span>
 <span class="co1">// template argument deduction comes up with two candidates:</span>
 <span class="co1">// foo&lt;int*&gt;(int*) and f&lt;int&gt;(int*)</span>
 <span class="co1">// partial ordering selects f&lt;int&gt;(int*) as more specialized</span></pre></div></div></div>
<p>Informally "A is more specialized than B" means "A accepts fewer types than B".
</p><p>Formally, to determine which of any two function templates is more specialized, the partial ordering process first transforms one of the two templates as follows:
</p>
<ul><li> For each type, non-type, and template parameter, including parameter packs, a unique fictitious type, value, or template is generated and substituted into function type of the template
</li><li> If only one of the two function templates being compared is a member function , and that function template is a non-static member of some class <code>A</code>, a new first parameter is inserted into its parameter list, whose type is <code>cv A&amp;&amp;</code> if the member function template is &amp;&amp;-qualified and <code>cv A&amp;</code> otherwise (cv is the cv-qualification of the member function template) -- this helps the ordering of operators, which are looked up both as member and as non-member functions:
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> A <span class="br0">&#123;</span><span class="br0">&#125;</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw1">struct</span> B <span class="br0">&#123;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> R<span class="sy1">&gt;</span> <span class="kw4">int</span> operator<span class="sy2">*</span><span class="br0">&#40;</span>R<span class="sy3">&amp;</span><span class="br0">&#41;</span><span class="sy4">;</span>                     <span class="co1">// #1</span>
<span class="br0">&#125;</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> R<span class="sy1">&gt;</span> <span class="kw4">int</span> operator<span class="sy2">*</span><span class="br0">&#40;</span>T<span class="sy3">&amp;</span>, R<span class="sy3">&amp;</span><span class="br0">&#41;</span><span class="sy4">;</span>          <span class="co1">// #2</span>
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  A a<span class="sy4">;</span>
  B<span class="sy1">&lt;</span>A<span class="sy1">&gt;</span> b<span class="sy4">;</span>
  b <span class="sy2">*</span> a<span class="sy4">;</span> <span class="co1">// template argument deduction for int B&lt;A&gt;::operator*(R&amp;) gives R=A </span>
         <span class="co1">//                             for int operator*(T&amp;, R&amp;), T=B&lt;A&gt;, R=A</span>
<span class="co1">// For the purpose of partial ordering, the member template B&lt;A&gt;::operator*</span>
<span class="co1">// is transformed into template&lt;class R&gt; int operator*(B&lt;A&gt;&amp;, R&amp;);</span>
<span class="co1">// partial ordering between </span>
<span class="co1">//     int operator*(   T&amp;, R&amp;)  T=B&lt;A&gt;, R=A</span>
<span class="co1">// and int operator*(B&lt;A&gt;&amp;, R&amp;)  R=A </span>
<span class="co1">// selects int operator*(B&lt;A&gt;&amp;, A&amp;) as more specialized</span></pre></div></div>
<p>After one of the two templates was transformed as described above, <a href="template_argument_deduction.html" title="cpp/language/template argument deduction">template argument deduction</a> is executed using the transformed template as the argument template and the original template type of the other template as the parameter template. The process is then repeated using the second template (after transformations) as the argument and the first template in its original form as the parameter.
</p><p>The types used to determine the order depend on the context:
</p>
<ul><li> in the context of a function call, the types are those function parameter types for which the function call has arguments (default function arguments, parameter packs, and ellipsis parameters are not considered -- see examples below)
</li><li> in the context of a call to a user-defined conversion function, the return types of the conversion function templates are used
</li><li> in other contexts, the function template type is used
</li></ul>
<p>Each type from the list above from the parameter template is deduced. Before deduction begins, each parameter <code><b>P</b></code> of the parameter template and the corresponding argument <code><b>A</b></code> of the argument template is adjusted as follows:
</p>
<ul><li> If both <code><b>P</b></code> and <code><b>A</b></code> are reference types before, determine which is more cv-qualified (in all other cases, cv-qualificiations are ignored for partial ordering purposes)
</li><li> If <code><b>P</b></code> is a reference type, it is replaced by the type referred to
</li><li> If <code><b>A</b></code> is a reference type, it is replaced by the type referred to
</li><li> If <code><b>P</b></code> is cv-qualified, <code><b>P</b></code> is replaced with cv-unqualified version of itself
</li><li> If <code><b>A</b></code> is cv-qualified, <code><b>A</b></code> is replaced with cv-unqualified version of itself
</li></ul>
<p>After these adjustments, deduction of <code><b>P</b></code> from <code><b>A</b></code> is done following <a href="template_argument_deduction.html#Deduction_from_a_type" title="cpp/language/template argument deduction">template argument deduction from a type</a>.
</p><p>If P is a function parameter pack, the type A of each remaining parameter type of the argument template is compared with the type P of the declarator-id of the function parameter pack. Each comparison deduces template arguments for subsequent positions in the template parameter packs expanded by the function parameter pack.
</p><p>If A was transformed from a function parameter pack, <span class="t-rev-inl t-until-cxx14"><span>deduction fails.</span> <span><span class="t-mark-rev t-until-cxx14">(until C++14)</span></span></span><span class="t-rev-inl t-since-cxx14"><span> it is compared with each remaining parameter type of the parameter template.</span> <span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>
</p><p>If the argument <code><b>A</b></code> of the transformed template-1 can be used to deduce the corresponding parameter <code><b>P</b></code> of template-2, but not vice versa, then this <code><b>A</b></code> is more specialized than <code><b>P</b></code> with regards to the type(s) that are deduced by this P/A pair.
</p><p>If deduction succeeds in both directions, and the original <code><b>P</b></code> and <code><b>A</b></code> were reference types, then additional tests are made:
</p>
<ul><li> If <code><b>A</b></code> was lvalue reference and <code><b>P</b></code> was rvalue reference, A is considered to be more specialized than P
</li><li> If <code><b>A</b></code> was more cv-qualified than <code><b>P</b></code>, A is considered to be more specialized than P
</li></ul>
<p>In all other cases, neither template is more specialized than the other with regards to the type(s) deduced by this P/A pair.
</p><p>After considering every P and A in both directions, if, for each type that was considered,
</p>
<ul><li> template-1 is at least as specialized as template-2 for all types
</li><li> template-1 is more specialized than template-2 for some types
</li><li> template-2 is not more specialized than template-1 for any types OR is not at least as specialized for any types
</li></ul>
<p>Then template-1 is more specialized than template-2. If the conditions above are true after switching template order, than template-2 is more specialized than template-1. Otherwise, neither template is more specialized than the other. 
In case of a tie, if one function template has a trailing parameter pack and the other does not, the one with the omitted parameter is considered to be more specialized than the one with the empty parameter pack.
</p><p>If, after considering all pairs of overloaded templates, there is one that is unambiguously more specialized than all others, that template's specialization is selected, otherwise compilation fails.
</p><p>In the following examples, the fictitious arguments will be called U1, U2
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="br0">&#41;</span><span class="sy4">;</span>        <span class="co1">// template #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="sy2">*</span><span class="br0">&#41;</span><span class="sy4">;</span>       <span class="co1">// template #2</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span><span class="kw4">const</span> T<span class="sy2">*</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// template #3</span>
<span class="kw4">void</span> m<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw4">const</span> <span class="kw4">int</span><span class="sy2">*</span> p<span class="sy4">;</span>
  f<span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// overload resolution picks: #1: void f(T ) [T = const int *]</span>
        <span class="co1">//                            #2: void f(T*) [T = const int]</span>
        <span class="co1">//                            #3: void f(const T *) [T = int]</span>
<span class="co1">// partial ordering</span>
<span class="co1">// #1 from transformed #2: void(T) from void(U1*): P=T A=U1*: deduction ok: T=U1*</span>
<span class="co1">// #2 from transformed #1: void(T*) from void(U1): P=T* A=U1: deduction fails</span>
<span class="co1">// #2 is more specialized than #1 with regards to T</span>
<span class="co1">// #1 from transformed #3: void(T) from void(const U1*): P=T, A=const U1*: ok</span>
<span class="co1">// #3 from transformed #1: void(const T*) from void(U1): P=const T*, A=U1: fails</span>
<span class="co1">// #3 is more specialized than #1 with regards to T</span>
<span class="co1">// #2 from transformed #3: void(T*) from void(const U1*): P=T* A=const U1*: ok</span>
<span class="co1">// #3 from transformed #2: void(const T*) from void(U1*): P=const T* A=U1*: fails</span>
<span class="co1">// #3 is more specialized than #2 with regards to T</span>
<span class="co1">// result: #3 is selected</span>
<span class="co1">// in other words, f(const T*) is more specialized than f(T) or f(T*)</span>
<span class="br0">&#125;</span></pre></div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T, T<span class="sy2">*</span><span class="br0">&#41;</span><span class="sy4">;</span>    <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T, <span class="kw4">int</span><span class="sy2">*</span><span class="br0">&#41;</span><span class="sy4">;</span>  <span class="co1">// #2</span>
<span class="kw4">void</span> m<span class="br0">&#40;</span><span class="kw4">int</span><span class="sy2">*</span> p<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    f<span class="br0">&#40;</span><span class="nu0">0</span>, p<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// deduction for #1: void f(T, T*) [T = int]</span>
             <span class="co1">// deduction for #2: void f(T, int*) [T = int]</span>
 <span class="co1">// partial ordering:</span>
 <span class="co1">// #1 from #2: void(T,T*) from void(U1,int*): P1=T, A1=U1: T=U1</span>
 <span class="co1">//                                            P2=T*, A2=int*: T=int: fails</span>
 <span class="co1">// #2 from #1: void(T,int*) from void(U1,U2*)&#160;: P1=T A1=U1: T=U1</span>
 <span class="co1">//                                              P2=int* A2=U2*: fails</span>
 <span class="co1">// neither is more specialized w.r.t T, the call is ambiguous</span>
<span class="br0">&#125;</span></pre></div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> g<span class="br0">&#40;</span>T<span class="br0">&#41;</span><span class="sy4">;</span>  <span class="co1">// template #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> g<span class="br0">&#40;</span>T<span class="sy3">&amp;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// template #2</span>
<span class="kw4">void</span> m<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw4">float</span> x<span class="sy4">;</span>
  g<span class="br0">&#40;</span>x<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// deduction from #1: void g(T ) [T = float]</span>
        <span class="co1">// deduction from #2: void g(T&amp;) [T = float]</span>
<span class="co1">// partial ordering</span>
<span class="co1">// #1 from #2: void(T) from void(U1&amp;): P=T, A=U1 (after adjustment), ok</span>
<span class="co1">// #2 from #1: void(T&amp;) from void(U1): P=T (after adjustment), A=U1: ok</span>
<span class="co1">// neither is more specialized w.r.t T, the call is ambiguous</span>
<span class="br0">&#125;</span></pre></div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw1">struct</span> A <span class="br0">&#123;</span> A<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="br0">&#125;</span><span class="sy4">;</span>
&#160;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> h<span class="br0">&#40;</span><span class="kw4">const</span> T<span class="sy3">&amp;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> h<span class="br0">&#40;</span>A<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy3">&amp;</span><span class="br0">&#41;</span><span class="sy4">;</span>    <span class="co1">// #2</span>
<span class="kw4">void</span> m<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  A<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> z<span class="sy4">;</span>
  h<span class="br0">&#40;</span>z<span class="br0">&#41;</span><span class="sy4">;</span>  <span class="co1">// deduction from #1: void h(const T &amp;) [T = A&lt;int&gt;]</span>
         <span class="co1">// deduction from #2: void h(A&lt;T&gt; &amp;) [T = int]</span>
 <span class="co1">// partial ordering</span>
 <span class="co1">// #1 from #2: void(const T&amp;) from void(A&lt;U1&gt;&amp;): P=T A=A&lt;U1&gt;: ok T=A&lt;U1&gt;</span>
 <span class="co1">// #2 from #1: void(A&lt;T&gt;&amp;) from void(const U1&amp;): P=A&lt;T&gt; A=const U1: fails</span>
 <span class="co1">// #2 is more specialized than #1 w.r.t T</span>
&#160;
  <span class="kw4">const</span> A<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> z2<span class="sy4">;</span>
  h<span class="br0">&#40;</span>z2<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// deduction from #1: void h(const T&amp;) [T = A&lt;int&gt;]</span>
         <span class="co1">// deduction from #2: void h(A&lt;T&gt;&amp;) [T = int], but substitution fails</span>
 <span class="co1">// only one overload to choose from, partial ordering not tried, #1 is called</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Since in a call context considers only parameters for which there are explicit call arguments, those function parameter packs, ellipsis parameters, and parameters with default arguments, for which there is no explicit call argument, are ignored:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>  <span class="kw4">void</span>  f<span class="br0">&#40;</span>T<span class="br0">&#41;</span><span class="sy4">;</span>               <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>  <span class="kw4">void</span>  f<span class="br0">&#40;</span>T<span class="sy2">*</span>, <span class="kw4">int</span><span class="sy1">=</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>       <span class="co1">// #2</span>
<span class="kw4">void</span> m<span class="br0">&#40;</span><span class="kw4">int</span><span class="sy2">*</span> ip<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  <span class="kw4">int</span><span class="sy2">*</span> ip<span class="sy4">;</span>
  f<span class="br0">&#40;</span>ip<span class="br0">&#41;</span><span class="sy4">;</span>     <span class="co1">// calls #2 (T* is more specialized than T)</span>
<span class="br0">&#125;</span></pre></div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span>  T<span class="sy1">&gt;</span>  <span class="kw4">void</span>  g<span class="br0">&#40;</span>T<span class="br0">&#41;</span><span class="sy4">;</span>               <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span>  T<span class="sy1">&gt;</span>  <span class="kw4">void</span>  g<span class="br0">&#40;</span>T<span class="sy2">*</span>, ...<span class="br0">&#41;</span><span class="sy4">;</span>         <span class="co1">// #2</span>
<span class="kw4">void</span> m<span class="br0">&#40;</span><span class="kw4">int</span><span class="sy2">*</span> ip<span class="br0">&#41;</span> <span class="br0">&#123;</span>
   g<span class="br0">&#40;</span>ip<span class="br0">&#41;</span><span class="sy4">;</span>     <span class="co1">// calls #2 (T* is more specialized than T)</span>
<span class="br0">&#125;</span></pre></div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> U<span class="sy1">&gt;</span> <span class="kw1">struct</span> A <span class="br0">&#123;</span> <span class="br0">&#125;</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> U<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>U, A<span class="sy1">&lt;</span>U,T<span class="sy1">&gt;</span><span class="sy2">*</span> p <span class="sy1">=</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span>         <span class="kw1">class</span> U<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>U, A<span class="sy1">&lt;</span>U,U<span class="sy1">&gt;</span><span class="sy2">*</span> p <span class="sy1">=</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// #2</span>
<span class="kw4">void</span> h<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  f<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">&#40;</span><span class="nu0">42</span>, <span class="br0">&#40;</span>A<span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="kw4">int</span><span class="sy1">&gt;</span><span class="sy2">*</span><span class="br0">&#41;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span>  <span class="co1">// calls #2</span>
  f<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">&#40;</span><span class="nu0">42</span><span class="br0">&#41;</span><span class="sy4">;</span>                   <span class="co1">// error: ambiguous</span>
<span class="br0">&#125;</span></pre></div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T           <span class="sy1">&gt;</span>  <span class="kw4">void</span> g<span class="br0">&#40;</span>T, T <span class="sy1">=</span> T<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>  <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span>... <span class="me1">U</span><span class="sy1">&gt;</span> <span class="kw4">void</span> g<span class="br0">&#40;</span>T, U ...<span class="br0">&#41;</span><span class="sy4">;</span>    <span class="co1">// #2</span>
<span class="kw4">void</span> h<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  g<span class="br0">&#40;</span><span class="nu0">42</span><span class="br0">&#41;</span><span class="sy4">;</span>  <span class="co1">// error: ambiguous</span>
<span class="br0">&#125;</span></pre></div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span>  T, <span class="kw1">class</span>... <span class="me1">U</span><span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T, U...<span class="br0">&#41;</span><span class="sy4">;</span>           <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span>  T            <span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="br0">&#41;</span><span class="sy4">;</span>                 <span class="co1">// #2</span>
<span class="kw4">void</span> h<span class="br0">&#40;</span><span class="kw4">int</span> i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  f<span class="br0">&#40;</span><span class="sy3">&amp;</span>i<span class="br0">&#41;</span><span class="sy4">;</span>        <span class="co1">// calls #2 due to the tie-breaker between parameter pack and no parameter</span>
                <span class="co1">// (note: was ambiguous between DR692 and DR1395)</span>
<span class="br0">&#125;</span></pre></div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span>  T, <span class="kw1">class</span>... <span class="me1">U</span><span class="sy1">&gt;</span> <span class="kw4">void</span> g<span class="br0">&#40;</span>T<span class="sy2">*</span>, U...<span class="br0">&#41;</span><span class="sy4">;</span>          <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span>  T            <span class="sy1">&gt;</span> <span class="kw4">void</span> g<span class="br0">&#40;</span>T<span class="br0">&#41;</span><span class="sy4">;</span>                 <span class="co1">// #2</span>
<span class="kw4">void</span> h<span class="br0">&#40;</span><span class="kw4">int</span> i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
  g<span class="br0">&#40;</span><span class="sy3">&amp;</span>i<span class="br0">&#41;</span><span class="sy4">;</span>        <span class="co1">// OK: calls #1 (T* is more specialized than T)</span>
<span class="br0">&#125;</span></pre></div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> ...<span class="me1">T</span><span class="sy1">&gt;</span> <span class="kw4">int</span> f<span class="br0">&#40;</span>T<span class="sy2">*</span>...<span class="br0">&#41;</span><span class="sy4">;</span>  <span class="co1">// #1</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>  <span class="kw4">int</span> f<span class="br0">&#40;</span><span class="kw4">const</span> T<span class="sy3">&amp;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// #2</span>
f<span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="sy2">*</span><span class="br0">&#41;</span><span class="nu0">0</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// OK: selects #1</span>
            <span class="co1">// (was ambiguous before DR1395 because deduction failed in both directions)</span></pre></div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span>... <span class="me1">Args</span><span class="sy1">&gt;</span>           <span class="kw4">void</span> f<span class="br0">&#40;</span>Args... <span class="me1">args</span><span class="br0">&#41;</span><span class="sy4">;</span>               <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T1, <span class="kw1">class</span>... <span class="me1">Args</span><span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T1 a1, Args... <span class="me1">args</span><span class="br0">&#41;</span><span class="sy4">;</span>        <span class="co1">// #2</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T1, <span class="kw1">class</span> T2<span class="sy1">&gt;</span>      <span class="kw4">void</span> f<span class="br0">&#40;</span>T1 a1, T2 a2<span class="br0">&#41;</span><span class="sy4">;</span>               <span class="co1">// #3</span>
f<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span>                  <span class="co1">// calls #1</span>
f<span class="br0">&#40;</span><span class="nu0">1</span>, <span class="nu0">2</span>, <span class="nu0">3</span><span class="br0">&#41;</span><span class="sy4">;</span>           <span class="co1">// calls #2</span>
f<span class="br0">&#40;</span><span class="nu0">1</span>, <span class="nu0">2</span><span class="br0">&#41;</span><span class="sy4">;</span>              <span class="co1">// calls #3; non-variadic template #3 is more</span>
                      <span class="co1">// specialized than the variadic templates #1 and #2</span></pre></div></div>
<p>During template argument deduction within the partial ordering process, template parameters don't require to be matched with arguments, if the argument is not used in any of the types considered for partial ordering
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>          T f<span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="sy4">;</span>  <span class="co1">// #1</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> U<span class="sy1">&gt;</span> T f<span class="br0">&#40;</span>U<span class="br0">&#41;</span><span class="sy4">;</span>    <span class="co1">// #2</span>
<span class="kw4">void</span> g<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
  f<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>  <span class="co1">// specialization of #1 is explicit: T f(int) [T = int]</span>
              <span class="co1">// specialization of #2 is deduced:  T f(U) [T = int, U = int]</span>
<span class="co1">// partial ordering (only considering the argument type)</span>
<span class="co1">// #1 from #2: T(int) from U1(U2): fails</span>
<span class="co1">// #2 from #1: T(U) from U1(int): ok: U=int, T unused</span>
<span class="co1">// calls #1</span>
<span class="br0">&#125;</span></pre></div></div>
<p>Partial ordering of function templates containing template parameter packs is independent of the number of deduced arguments for those template parameter packs.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span>...<span class="sy1">&gt;</span> <span class="kw1">struct</span> Tuple <span class="br0">&#123;</span> <span class="br0">&#125;</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span>          <span class="kw1">class</span>... <span class="me1">Types</span><span class="sy1">&gt;</span> <span class="kw4">void</span> g<span class="br0">&#40;</span>Tuple<span class="sy1">&lt;</span>Types ...<span class="sy1">&gt;</span><span class="br0">&#41;</span><span class="sy4">;</span>        <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T1, <span class="kw1">class</span>... <span class="me1">Types</span><span class="sy1">&gt;</span> <span class="kw4">void</span> g<span class="br0">&#40;</span>Tuple<span class="sy1">&lt;</span>T1, Types ...<span class="sy1">&gt;</span><span class="br0">&#41;</span><span class="sy4">;</span>    <span class="co1">// #2</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T1, <span class="kw1">class</span>... <span class="me1">Types</span><span class="sy1">&gt;</span> <span class="kw4">void</span> g<span class="br0">&#40;</span>Tuple<span class="sy1">&lt;</span>T1, Types<span class="sy3">&amp;</span> ...<span class="sy1">&gt;</span><span class="br0">&#41;</span><span class="sy4">;</span>   <span class="co1">// #3</span>
&#160;
g<span class="br0">&#40;</span>Tuple<span class="sy1">&lt;&gt;</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>                     <span class="co1">// calls #1</span>
g<span class="br0">&#40;</span>Tuple<span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="kw4">float</span><span class="sy1">&gt;</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>           <span class="co1">// calls #2</span>
g<span class="br0">&#40;</span>Tuple<span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="kw4">float</span><span class="sy3">&amp;</span><span class="sy1">&gt;</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>          <span class="co1">// calls #3</span>
g<span class="br0">&#40;</span>Tuple<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>                  <span class="co1">// calls #3</span></pre></div></div>
<p><br />
</p>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br />Reason: 14.8.3[temp.over] </td></tr></table>
<p>To compile a call to a function template, the compiler has to decide between non-template overloads, template overloads, and the specializations of the template overloads.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw1">class</span> T <span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="br0">&#41;</span><span class="sy4">;</span>              <span class="co1">// #1: template overload</span>
<span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw1">class</span> T <span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="sy2">*</span><span class="br0">&#41;</span><span class="sy4">;</span>             <span class="co1">// #2: template overload</span>
<span class="kw4">void</span>                     f<span class="br0">&#40;</span><span class="kw4">double</span><span class="br0">&#41;</span><span class="sy4">;</span>         <span class="co1">// #3: nontemplate overload</span>
<span class="kw1">template</span><span class="sy1">&lt;&gt;</span>          <span class="kw4">void</span> f<span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span><span class="sy4">;</span>            <span class="co1">// #4: specialization of #1</span>
&#160;
f<span class="br0">&#40;</span><span class="st0">'a'</span><span class="br0">&#41;</span><span class="sy4">;</span>        <span class="co1">// calls #1</span>
f<span class="br0">&#40;</span>new <span class="kw4">int</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// calls #2</span>
f<span class="br0">&#40;</span><span class="nu16">1.0</span><span class="br0">&#41;</span><span class="sy4">;</span>        <span class="co1">// calls #3</span>
f<span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy4">;</span>          <span class="co1">// calls #4</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;action=edit&amp;section=11" title="Edit section: Function overloads vs function specializations">edit</a>]</span> <span class="mw-headline" id="Function_overloads_vs_function_specializations">Function overloads vs function specializations</span></h3>
<p>Note that only non-template and primary template overloads participate in overload resolution. The specializations are not overloads and are not considered. Only after the overload resolution selects the best-matching primary function template, its specializations are examined to see if one is a better match.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw1">class</span> T <span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="br0">&#41;</span><span class="sy4">;</span>    <span class="co1">// #1: overload for all types</span>
<span class="kw1">template</span><span class="sy1">&lt;&gt;</span>          <span class="kw4">void</span> f<span class="br0">&#40;</span><span class="kw4">int</span><span class="sy2">*</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// #2: specialization of #1 for pointers to int</span>
<span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw1">class</span> T <span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="sy2">*</span><span class="br0">&#41;</span><span class="sy4">;</span>   <span class="co1">// #3: overload for all pointer types</span>
&#160;
f<span class="br0">&#40;</span>new <span class="kw4">int</span><span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// calls #3, even though specialization of #1 would be a perfect match</span></pre></div></div>
<p>It is important to remember this rule while ordering the header files of a translation unit. For more examples of the interplay between function overloads and function specializations, expand below:
</p>
<hr />
<table style="border-style: none; border-spacing: 2px; width: 100%;" class="mw-collapsible mw-collapsed">

<tr>
<td>
<p><br />
</p>
</td></tr>
<tr>
<td>
<p>Consider first some scenarios where the argument-dependent lookup is not employed. For that, we use the call <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">&#40;</span>f<span class="br0">&#41;</span><span class="br0">&#40;</span>t<span class="br0">&#41;</span></span></span>. As described in <a href="adl.html" title="cpp/language/adl">ADL</a>, wrapping the function name in parentheses is suppressing the argument-dependent lookup.
</p>
<ul><li> Multiple overloads of <span class="t-c"><span class="mw-geshi cpp source-cpp">f<span class="br0">&#40;</span><span class="br0">&#41;</span></span></span> declared before the <i>point-of-reference</i> (POR) in <span class="t-c"><span class="mw-geshi cpp source-cpp">g<span class="br0">&#40;</span><span class="br0">&#41;</span></span></span>.
</li></ul>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="kw1">struct</span> A<span class="br0">&#123;</span><span class="br0">&#125;</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="br0">&#41;</span>    <span class="br0">&#123;</span><a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;#1<span class="es1">\n</span>&quot;</span><span class="sy4">;</span><span class="br0">&#125;</span> <span class="co1">// overload #1 before f() POR</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="sy2">*</span><span class="br0">&#41;</span>   <span class="br0">&#123;</span><a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;#2<span class="es1">\n</span>&quot;</span><span class="sy4">;</span><span class="br0">&#125;</span> <span class="co1">// overload #2 before f() POR</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> g<span class="br0">&#40;</span>T<span class="sy2">*</span> t<span class="br0">&#41;</span> 
<span class="br0">&#123;</span>
    <span class="br0">&#40;</span>f<span class="br0">&#41;</span><span class="br0">&#40;</span>t<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// f() POR</span>
<span class="br0">&#125;</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    A <span class="sy2">*</span>p<span class="sy1">=</span>nullptr<span class="sy4">;</span>
    g<span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>           <span class="co1">// POI of g() and f()</span>
&#160;
<span class="co1">// Both #1 and #2 are added to the candidate list;</span>
<span class="co1">// #2 is selected because it is a better match.</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">#2</pre></div></div> 
</div>
<p><br />
</p>
<ul><li> A better matching template overload is declared after POR.
</li></ul>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="kw1">struct</span> A<span class="br0">&#123;</span><span class="br0">&#125;</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="br0">&#41;</span>    <span class="br0">&#123;</span><a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;#1<span class="es1">\n</span>&quot;</span><span class="sy4">;</span><span class="br0">&#125;</span> <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> g<span class="br0">&#40;</span>T<span class="sy2">*</span> t<span class="br0">&#41;</span> 
<span class="br0">&#123;</span>
    <span class="br0">&#40;</span>f<span class="br0">&#41;</span><span class="br0">&#40;</span>t<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// f() POR</span>
<span class="br0">&#125;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="sy2">*</span><span class="br0">&#41;</span>   <span class="br0">&#123;</span><a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;#2<span class="es1">\n</span>&quot;</span><span class="sy4">;</span><span class="br0">&#125;</span> <span class="co1">// #2</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    A <span class="sy2">*</span>p<span class="sy1">=</span>nullptr<span class="sy4">;</span>
    g<span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>           <span class="co1">// POI of g() and f()</span>
&#160;
<span class="co1">// Only #1 is added to the candidate list; #2 is defined after POR;</span>
<span class="co1">// therefore, it is not considered for overloading even if it is a better match.</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">#1</pre></div></div> 
</div>
<p><br />
</p>
<ul><li> A better matching explicit template specialization is declared after POR.
</li></ul>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="kw1">struct</span> A<span class="br0">&#123;</span><span class="br0">&#125;</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="br0">&#41;</span>    <span class="br0">&#123;</span><a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;#1<span class="es1">\n</span>&quot;</span><span class="sy4">;</span><span class="br0">&#125;</span> <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> g<span class="br0">&#40;</span>T<span class="sy2">*</span> t<span class="br0">&#41;</span> 
<span class="br0">&#123;</span>
    <span class="br0">&#40;</span>f<span class="br0">&#41;</span><span class="br0">&#40;</span>t<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// f() POR</span>
<span class="br0">&#125;</span>
<span class="kw1">template</span><span class="sy1">&lt;&gt;</span>        <span class="kw4">void</span> f<span class="sy1">&lt;&gt;</span><span class="br0">&#40;</span>A<span class="sy2">*</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;#3<span class="es1">\n</span>&quot;</span><span class="sy4">;</span><span class="br0">&#125;</span> <span class="co1">// #3</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    A <span class="sy2">*</span>p<span class="sy1">=</span>nullptr<span class="sy4">;</span>
    g<span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>           <span class="co1">// POI of g() and f()</span>
&#160;
<span class="co1">// #1 is added to the candidate list; #3 is a better match defined after POR. The</span>
<span class="co1">// candidate list consists of #1 which is eventually selected. After that, the explicit </span>
<span class="co1">// specialization #3 of #1 declared after POI is selected because it is a better match. </span>
<span class="co1">// This behavior is governed by 14.7.3/6 [temp.expl.spec] and has nothing to do with ADL.</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">#3</pre></div></div> 
</div>
<p><br />
</p>
<ul><li> A better matching template overload is declared after POR. The best matching explicit template specialization is declared after the better matching overload.
</li></ul>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="kw1">struct</span> A<span class="br0">&#123;</span><span class="br0">&#125;</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="br0">&#41;</span>    <span class="br0">&#123;</span><a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;#1<span class="es1">\n</span>&quot;</span><span class="sy4">;</span><span class="br0">&#125;</span> <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> g<span class="br0">&#40;</span>T<span class="sy2">*</span> t<span class="br0">&#41;</span> 
<span class="br0">&#123;</span>
    <span class="br0">&#40;</span>f<span class="br0">&#41;</span><span class="br0">&#40;</span>t<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// f() POR</span>
<span class="br0">&#125;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="sy2">*</span><span class="br0">&#41;</span>   <span class="br0">&#123;</span><a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;#2<span class="es1">\n</span>&quot;</span><span class="sy4">;</span><span class="br0">&#125;</span> <span class="co1">// #2</span>
<span class="kw1">template</span><span class="sy1">&lt;&gt;</span>        <span class="kw4">void</span> f<span class="sy1">&lt;&gt;</span><span class="br0">&#40;</span>A<span class="sy2">*</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;#3<span class="es1">\n</span>&quot;</span><span class="sy4">;</span><span class="br0">&#125;</span> <span class="co1">// #3</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    A <span class="sy2">*</span>p<span class="sy1">=</span>nullptr<span class="sy4">;</span>
    g<span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>           <span class="co1">// POI of g() and f()</span>
&#160;
<span class="co1">// #1 is the only member of the candidate list and it is eventually selected. </span>
<span class="co1">// After that, the explicit specialization #3 is skipped because it actually </span>
<span class="co1">// specializes #2 declared after POR.</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">#1</pre></div></div> 
</div>
<p><br />
Let's consider now those cases employing argument-dependent lookup (i.e., we use the more common call format <span class="t-c"><span class="mw-geshi cpp source-cpp">f<span class="br0">&#40;</span>t<span class="br0">&#41;</span></span></span>).
</p>
<ul><li> A better matching template overload is declared after POR.
</li></ul>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="kw1">struct</span> A<span class="br0">&#123;</span><span class="br0">&#125;</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="br0">&#41;</span>    <span class="br0">&#123;</span><a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;#1<span class="es1">\n</span>&quot;</span><span class="sy4">;</span><span class="br0">&#125;</span> <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> g<span class="br0">&#40;</span>T<span class="sy2">*</span> t<span class="br0">&#41;</span> 
<span class="br0">&#123;</span>
    f<span class="br0">&#40;</span>t<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// f() POR</span>
<span class="br0">&#125;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="sy2">*</span><span class="br0">&#41;</span>   <span class="br0">&#123;</span><a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;#2<span class="es1">\n</span>&quot;</span><span class="sy4">;</span><span class="br0">&#125;</span> <span class="co1">// #2</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    A <span class="sy2">*</span>p<span class="sy1">=</span>nullptr<span class="sy4">;</span>
    g<span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>           <span class="co1">// POI of g() and f()</span>
&#160;
<span class="co1">// #1 is added to the candidate list as a result of the ordinary lookup;</span>
<span class="co1">// #2 is defined after POR but it is added to the candidate list via ADL lookup.</span>
<span class="co1">// #2 is selected being the better match.</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">#2</pre></div></div> 
</div>
<p><br />
</p>
<ul><li> A better matching template overload is declared after POR. The best matching explicit template specialization is declared before the better matching overload.
</li></ul>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="kw1">struct</span> A<span class="br0">&#123;</span><span class="br0">&#125;</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="br0">&#41;</span>    <span class="br0">&#123;</span><a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;#1<span class="es1">\n</span>&quot;</span><span class="sy4">;</span><span class="br0">&#125;</span> <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> g<span class="br0">&#40;</span>T<span class="sy2">*</span> t<span class="br0">&#41;</span> 
<span class="br0">&#123;</span>
    f<span class="br0">&#40;</span>t<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// f() POR</span>
<span class="br0">&#125;</span>
<span class="kw1">template</span><span class="sy1">&lt;&gt;</span>        <span class="kw4">void</span> f<span class="sy1">&lt;&gt;</span><span class="br0">&#40;</span>A<span class="sy2">*</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;#3<span class="es1">\n</span>&quot;</span><span class="sy4">;</span><span class="br0">&#125;</span> <span class="co1">// #3</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="sy2">*</span><span class="br0">&#41;</span>   <span class="br0">&#123;</span><a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;#2<span class="es1">\n</span>&quot;</span><span class="sy4">;</span><span class="br0">&#125;</span> <span class="co1">// #2</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    A <span class="sy2">*</span>p<span class="sy1">=</span>nullptr<span class="sy4">;</span>
    g<span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>           <span class="co1">// POI of g() and f()</span>
&#160;
<span class="co1">// #1 is added to the candidate list as a result of the ordinary lookup;</span>
<span class="co1">// #2 is defined after POR but it is added to the candidate list via ADL lookup.</span>
<span class="co1">// #2 is selected among the primary templates, being the better match.</span>
<span class="co1">// Since #3 is declared before #2, it is an explicit specialization of #1.</span>
<span class="co1">// Hence the final selection is #2.</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">#2</pre></div></div> 
</div>
<p><br />
</p>
<ul><li> A better matching template overload is declared after POR. The best matching explicit template specialization is declared last.
</li></ul>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="kw1">struct</span> A<span class="br0">&#123;</span><span class="br0">&#125;</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="br0">&#41;</span>    <span class="br0">&#123;</span><a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;#1<span class="es1">\n</span>&quot;</span><span class="sy4">;</span><span class="br0">&#125;</span> <span class="co1">// #1</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> g<span class="br0">&#40;</span>T<span class="sy2">*</span> t<span class="br0">&#41;</span> 
<span class="br0">&#123;</span>
    f<span class="br0">&#40;</span>t<span class="br0">&#41;</span><span class="sy4">;</span> <span class="co1">// f() POR</span>
<span class="br0">&#125;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">void</span> f<span class="br0">&#40;</span>T<span class="sy2">*</span><span class="br0">&#41;</span>   <span class="br0">&#123;</span><a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;#2<span class="es1">\n</span>&quot;</span><span class="sy4">;</span><span class="br0">&#125;</span> <span class="co1">// #2</span>
<span class="kw1">template</span><span class="sy1">&lt;&gt;</span>        <span class="kw4">void</span> f<span class="sy1">&lt;&gt;</span><span class="br0">&#40;</span>A<span class="sy2">*</span><span class="br0">&#41;</span> <span class="br0">&#123;</span><a href="../io/cout.html"><span class="kw1755">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">&quot;#3<span class="es1">\n</span>&quot;</span><span class="sy4">;</span><span class="br0">&#125;</span> <span class="co1">// #3</span>
&#160;
<span class="kw4">int</span> main<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    A <span class="sy2">*</span>p<span class="sy1">=</span>nullptr<span class="sy4">;</span>
    g<span class="br0">&#40;</span>p<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>           <span class="co1">// POI of g() and f()</span>
&#160;
<span class="co1">// #1 is added to the candidate list as a result of the ordinary lookup;</span>
<span class="co1">// #2 is defined after POR but it is added to the candidate list via ADL lookup.</span>
<span class="co1">// #2 is selected among the primary templates, being the better match.</span>
<span class="co1">// Since #3 is declared after #2, it is an explicit specialization of #2;</span>
<span class="co1">// therefore, selected as the function to call.</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">#3</pre></div></div> 
</div>
<p><br />
Whenever the arguments are some C++ basic types, there are no ADL-associated namespaces. Hence, those scenarios are identical with the non-ADL examples above.
</p>
</td></tr></table>
<hr />
<p>For detailed rules on overload resolution, see <a href="overload_resolution.html" title="cpp/language/overload resolution">overload resolution</a>
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;action=edit&amp;section=12" title="Edit section: Function template specialization">edit</a>]</span> <span class="mw-headline" id="Function_template_specialization">Function template specialization</span></h3>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br />Reason: 14.8[temp.fct.spec] (note that 14.8.1[temp.arg.explicit] is already in full specialization article: either function specifics go here: lack of partials, interaction with function overloads, or just refer to that </td></tr></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;action=edit&amp;section=13" title="Edit section: Defect reports">edit</a>]</span> <span class="mw-headline" id="Defect_reports">Defect reports</span></h3>
<p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.
</p>
<table class="dsctable" style="font-size:0.8em">
<tr>
<th> DR
</th>
<th> Applied to
</th>
<th> Behavior as published
</th>
<th> Correct behavior
</th></tr>
<tr>
<td> <a rel="nofollow" class="external text" href="https://wg21.link/cwg1395">CWG 1395</a>
</td>
<td> C++14
</td>
<td> deduction failed when A was from a pack, and there was no empty pack tie-breaker
</td>
<td> deduction allowed, tie-breaker added
</td></tr></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;action=edit&amp;section=14" title="Edit section: See Also">edit</a>]</span> <span class="mw-headline" id="See_Also">See Also</span></h3>
<ul><li> <a href="class_template.html" title="cpp/language/class template">class template</a>
</li><li> <a href="function.html" title="cpp/language/function">function declaration</a>
</li></ul>

<!-- 
NewPP limit report
Preprocessor visited node count: 4698/1000000
Preprocessor generated node count: 12550/1000000
Post‐expand include size: 73285/2097152 bytes
Template argument size: 43708/2097152 bytes
Highest expansion depth: 17/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:5067-0!*!0!!en!*!* and timestamp 20190514151329 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;oldid=110677">https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;oldid=110677</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id='catlinks' class='catlinks'><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="https://en.cppreference.com/w/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="https://en.cppreference.com/w/Category:Todo_with_reason" title="Category:Todo with reason">Todo with reason</a></li></ul></div><div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden category: <ul><li><a href="https://en.cppreference.com/w/Category:Pages_with_unreviewed_CWG_DR_marker" title="Category:Pages with unreviewed CWG DR marker">Pages with unreviewed CWG DR marker</a></li></ul></div></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        <div id="cpp-footer-base" class="noprint">
            <div id="footer">
                        <div id="cpp-navigation">
            <h5>Navigation</h5>
            <ul>
<li id="n-Support-us"><a href="http://www.cppreference.com/support" rel="nofollow">Support us</a></li><li id="n-recentchanges"><a href="https://en.cppreference.com/w/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-FAQ"><a href="https://en.cppreference.com/w/Cppreference:FAQ">FAQ</a></li><li id="n-Offline-version"><a href="https://en.cppreference.com/w/Cppreference:Archives">Offline version</a></li>            </ul>
        </div>
                        <div id="cpp-toolbox">
            <h5><span>Toolbox</span><a href="function_template.html#"></a></h5>
            <ul>
<li id="t-whatlinkshere"><a href="https://en.cppreference.com/w/Special:WhatLinksHere/cpp/language/function_template" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="https://en.cppreference.com/w/Special:RecentChangesLinked/cpp/language/function_template" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-upload"><a href="http://upload.cppreference.com/w/Special:Upload" title="Upload files [u]" accesskey="u">Upload file</a></li><li id="t-specialpages"><a href="https://en.cppreference.com/w/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;oldid=110677" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/function_template&amp;action=info">Page information</a></li>            </ul>
        </div>
                        <div id="cpp-languages">
            <div><ul><li>In other languages</li></ul></div>
            <div><ul>
<li class="interwiki-de"><a href="http://de.cppreference.com/w/cpp/language/function_template" title="cpp/language/function template" lang="de" hreflang="de">Deutsch</a></li><li class="interwiki-es"><a href="http://es.cppreference.com/w/cpp/language/function_template" title="cpp/language/function template" lang="es" hreflang="es">Español</a></li><li class="interwiki-fr"><a href="http://fr.cppreference.com/w/cpp/language/function_template" title="cpp/language/function template" lang="fr" hreflang="fr">Français</a></li><li class="interwiki-it"><a href="http://it.cppreference.com/w/cpp/language/function_template" title="cpp/language/function template" lang="it" hreflang="it">Italiano</a></li><li class="interwiki-ja"><a href="http://ja.cppreference.com/w/cpp/language/function_template" title="cpp/language/function template" lang="ja" hreflang="ja">日本語</a></li><li class="interwiki-pt"><a href="http://pt.cppreference.com/w/cpp/language/function_template" title="cpp/language/function template" lang="pt" hreflang="pt">Português</a></li><li class="interwiki-ru"><a href="http://ru.cppreference.com/w/cpp/language/function_template" title="cpp/language/function template" lang="ru" hreflang="ru">Русский</a></li><li class="interwiki-zh"><a href="http://zh.cppreference.com/w/cpp/language/function_template" title="cpp/language/function template" lang="zh" hreflang="zh">中文</a></li>            </ul></div>
        </div>
            <ul id="footer-info">
                                    <li id="footer-info-lastmod"> This page was last modified on 14 May 2019, at 08:13.</li>
                                    <li id="footer-info-viewcount">This page has been accessed 976,139 times.</li>
                            </ul>
                    <ul id="footer-places">
                                    <li id="footer-places-privacy"><a href="https://en.cppreference.com/w/Cppreference:Privacy_policy" title="Cppreference:Privacy policy">Privacy policy</a></li>
                                    <li id="footer-places-about"><a href="https://en.cppreference.com/w/Cppreference:About" title="Cppreference:About">About cppreference.com</a></li>
                                    <li id="footer-places-disclaimer"><a href="https://en.cppreference.com/w/Cppreference:General_disclaimer" title="Cppreference:General disclaimer">Disclaimers</a></li>
                            </ul>
                                    <ul id="footer-icons" class="noprint">
                                    <li id="footer-poweredbyico">
                                            <a href="https://www.mediawiki.org/"><img src="../../../mwiki/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>                                            <a href="http://qbnz.com/highlighter/"><img src="../../../../upload.cppreference.com/mwiki/images/2/2b/powered_by_geshi_88x31.png" alt="Powered by GeSHi" height="31" width="88" /></a>                                            <a href="http://www.tigertech.net/referral/cppreference.com"><img src="../../../../upload.cppreference.com/mwiki/images/9/94/powered_by_tigertech_88x31.png" alt="Hosted by Tiger Technologies" height="31" width="88" /></a>                                        </li>
                                </ul>
                        <div style="clear:both">
            </div>
            </div>
        </div>
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="../../../mwiki/load.php%3Fdebug=false&amp;lang=en&amp;modules=skins.cppreference2&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler","ext.gadget.MathJax"], null, true);
}</script>
<script src="../../../mwiki/load.php%3Fdebug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-2828341-1']);
_gaq.push(['_setDomainName', 'cppreference.com']);
_gaq.push(['_trackPageview']);
</script><!-- Served in 0.043 secs. -->
	</body>
<!-- Cached 20190514151426 -->
</html>
